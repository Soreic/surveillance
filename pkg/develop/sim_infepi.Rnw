@
<<echo=F>>=
######################################################################
#Small helper function - not documented.
#Secure rexp handling theta=0 arguments
######################################################################
rexp2 <- function(n,theta) {
  if (theta==0) {
    rep(Inf,n)
  } else {
    rexp(n,theta)
  }
}
@
 
\name{sim.sir}
\alias{sim.sir}
\title{Generate a SEIR like Epidemic}
\description{Simulation of epidemics based on a SEIR model.}
\arguments{
  \item{S0}{Initial number of susceptibles}
\item{I0}{Initial number of infectious (typically 1)}
\item{lambda}{Contact parameter}
\item{eta}{1/mean of exponentially distributed incubation time}
\item{gamma}{1/mean of exponentially distributed infection time}
}
\value{A Time series for dI aggregated in 7 day intervals}
\seealso{\link{\code{sim.infepi}}}

<<echo=F>>=
######################################################################
# Simulate SEIR epidemic using an approximative inference method, i.e.
# use an inhomogenous markov chain and update time in small
# discrete time steps. Data are aggregated to weeks.
#
# Parameters:
#  S0 - Initial number of susceptibles
#  I0 - Initial number of infectious (typically 1)
#  lambda - Contact parameter
#  eta    - 1/mean of exponentially distributed incubation time
#  gamma  - 1/mean of exponentially distributed infection time
#
# Returns:
#  Time series for dI aggregated in 7 day intervals
#
######################################################################

sim.sir <- function(S0,I0,lambda,eta,gamma,timestep=1) {
  S <- S0
  E <- 0
  I <- I0
  R <- 0
  #New cases
  dI<- 0
  t <- 1

  #Loop
  while (I[t]>0 | E[t]>0) {
    #How many s->e
    newE <- sum(rexp2(S[t],lambda*I[t]) < timestep)
    #How many e->i
    newI <- sum(rexp2(E[t],eta) < timestep)
    #How many i->r
    newR <- sum(rexp2(I[t],gamma) < timestep)

    #Update the counters
    S <- c(S,S[t]-newE)
    E <- c(E,E[t]+newE-newI)
    I <- c(I,I[t]+newI-newR)
    dI <- c(dI,newI)
    R <- c(R,R[t]+newR)
    #Update time
    t <- t+1
  }

  #Done - now aggregate to weeks
  n <- length(dI)
  if (7/timestep - trunc(7/timestep) > 0) {
    stop("Error in sim.sir: 7/timestep has to be an integer!")
  }

  #Create a factor telling which week each time point belongs to.
  weekno <- rep(1:n,each=(7/timestep),length.out=n)

  #Sum within each week
  wcases <- as.integer(by(dI,weekno,sum))

  #Done
  return(wcases)
}

@ 

\name{sim.infepi}
\alias{sim.infepi}
\title{Generation of Simulated SIR like Epidemic}
\description{Simulation of epidemics based on a seasonal background to
on top which SIR epidemic are added.}

}
\usage{
    sim.infepi(p = 0.99, r = 0.01, length = 400, A = 1, alpha = 1,
                        beta = 0, phi = 0, frequency = 1, state = NULL, control.sir=list(S0=100,lambda=0.1,eta=0.1gamma=0.1))
}
\arguments{
        \item{p}{probability to get a new epidemy at time i if there was one at time i-1, default 0.99.}
        \item{r}{probability to get no new epidemy at time i if there was none at time i-1, default 0.01.}
        \item{length}{number of weeks to model, default 400. \code{length} is ignored if \code{state}
                        is given. In this case the length of \code{state} is used.}
        \item{A}{amplitude (range of sinus), default = 1.}
        \item{alpha}{parameter to move along the y-axis (negative values not allowed)
                       with alpha > = A, default = 1.}
        \item{beta}{regression coefficient, default = 0.}
        \item{phi}{factor to create seasonal moves
                        (moves the curve along the x-axis), default = 0.}
        \item{frequency}{factor to determine the oscillation-frequency, default = 1.}
        \item{state}{use a state chain to define the status at this timepoint (outbreak or not).
                If not given a Markov chain is generated by the programme, default NULL.}
        \item{control.infepi}{List with control parameters for the INFEPI epidemic. That is \code{S0} the mean number of susceptibles for the INFEPI outbreak. The epidemic always starts of with one initial infective. Furtheremore, \code{lambda} is the contact rate (unit: days), \code{eta} is 1/mean of the exponential distributed incubation time and \code{gamma} is 1/mean of the exponential distributed infection time.}
}
\value{
        \item{disProg}{a object \code{disProg} (disease progress) including a list of the observed, the state chain
                and nearly all input parameters.
        }
}
\seealso{\code{\link{sim.seasonalNoise}}
}
\author{Michael Höhle}
\examples{
    # Plotting of simulated data
    disProgObj <- sim.infepi(p = 0.99, r = 0.5, length = 208,
                                    A = 1, alpha = 1, beta = 0, phi = 0,
                                    frequency = 1, state = NULL, K = 2)
    # plot the simulated disease with the defined outbreaks
    plot(disProgObj)

    state <- rep(c(0,0,0,0,0,0,0,0,1,1), 20)
    disProgObj <- sim.infepi(state = state, K = 1.2)
    plot(disProgObj)
}

\keyword{}

<<echo=F>>=

# Programme to simulate epidemies which were
# introduced by point sources.
# The basis of this proagramme is a combination of
# a Hidden Markov Modell (to get random dates
# for outbreaks) and a simple Model to simulate
# the epidemy.
#
# Parameters:
# r - probability to get a new epidemy at time i if there was one
#     at time i-1
# p - probability to get no new epidemy at time i if there was none
#     at time i-1
# length - number of timesteps to visit
#
# Parameters for the background:
# A - Amplitude, default = 1.
# alpha - Incidence, default = 1.
# beta - time dependent regression coefficient, default = 0.
# phi - weeks of seaonal move, default = 0.
# frequency - frequency of the sinus, default = 1.
# state - a eventually given markov chain,
#               which defines the status at this time (outbreak or not)
# K - additional weigth for an outbreak

sim.infepi <- function(p = 0.99, r = 0.01, length = 400, A = 1, alpha = 1, beta = 0,
                                phi = 0, frequency = 1, state = NULL, 
                    control.sir=list(S0=100,lambda=0.01,eta=0.1,gamma=0.1)
                    ){

  #Create the state ts?
  if(is.null(state)){
        # create a markov-chain
    state <- matrix(data = 0, ncol = 1, nrow = length)
    state[1] <- 0 # always start with nothing!

    # create the transition matrix
    P <- matrix(data = c(p, (1-r),(1-p), r), nrow = 2, ncol = 2)

    if(length(state) > 1){ # just do it if there is a preceding value
      for (i in 2:length){
        # check the matrix for the correct line and take the right
        # probability. The last value of state is the newest.
        state[i] <- rbinom(1,1,P[state[i-1] + 1, 2])
      }
    }
  }

  # go sure to have the rigth length as parameter
  length <- length(state)

  #background number
  observed <-sim.seasonalNoise(A, alpha, beta, phi, length, frequency, state, K=0)$seasonalBackground

  #Find the number to add in case of outbreaks
  outbreak <- numeric(length)
  for (i in 1:length) {
    if (state[i]==1) {
      #Sim a SIR epidemic and count no of new cases aggregated for each week
      epi <- sim.sir(S0=rpois(1,control.sir$S0),I0=1,
                     lambda=control.sir$lambda,eta=control.sir$eta,
                     gamma=control.sir$gamma)
      n <- length(epi)
      #Add the number of cases
      idx <- i:min(length,(i+n-1))
      outbreak[idx] <- outbreak[idx] + epi[idx-i+1]
    }
  }

  #State is defined to be everywhere where there is an outbreak (not good)
  state   <- outbreak>0
  observed<- observed + outbreak
  result <- list(observed = observed, state = state, A = A, alpha = alpha, beta = beta, outbreak = outbreak, control.sir=control.sir,p = p, r = r)
  class(result) = "disProg" # for disease progress

  return(result)
}



