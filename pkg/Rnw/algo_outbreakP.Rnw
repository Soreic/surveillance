@

\name{algo.outbreakP}
\alias{algo.outbreakP}
\alias{calc.outbreakP.statistic}
\title{Semiparametric surveillance of outbreaks}
\description{
  Frisen and Andersson (2009) method for semiparametric surveillance of outbreaks
}
\usage{
    algo.outbreakP(disProgObj, control = list(range = range, k=100, 
                   ret=c("cases","value"),maxUpperboundCases=1e5))
}
\arguments{
\item{disProgObj}{object of class disProg (including the observed and the state chain).}
\item{control}{A list controlling the behaviour of the algorithm
    \describe{
    \item{\code{range}}{determines the desired
        time-points which should be monitored. Note that it is
        automatically assumed that ALL other values in \code{disProgObj}
        can be used for the estimation, i.e. for a specific value \code{i}
        in \code{range} all values from 1 to \code{i} are used for estimation.}
    \item{\code{k}}{The threshold value. Once the outbreak statistic
        is above this threshold \code{k} an alarm is sounded.}
    \item{\code{ret}}{a string specifying the type of
        \code{upperbound}-statistic that is returned. With
        \code{"cases"} the number of cases that would have been
        necessary to produce an alarm (NNBA) or with \code{"value"} the
        outbreakP-statistic is computed (see below).}
    \item{\code{maxUpperboundCases}}{Upperbound when numerically searching
        for NNBA. Default is 1e5.}
    }
  }
}
\value{
\item{survRes}{
    \code{algo.outbreakP} gives a list of class \code{survRes} which
    includes the vector of alarm values for every time-point in
    \code{range}, the vector of threshold values for every time-point
    in \code{range}.  
  }
}
\details{
  A generalized likelihood ratio test based on the Poisson
  distribution is implemented where the means of the in-control and
  out-of-control states are computed by isotonic regression.

 \deqn{OutbreakP(s) = \prod_{t=1}^s \left( \frac{\hat{\mu}^{C1}(t)}{\hat{\mu}^D(t)} \right)^{x(t)} },

 where \eqn{\hat{\mu}^{C1}(t)} is the estimated mean obtained by
 uni-modal regression under the assumption of one change-point and
 \eqn{\hat{\mu}^D(t)} is the estimated result when there is no
 change-point (i.e. this is just the mean of all observations). Note
 that the contrasted hypothesis assume all means are equal until the
 change-point, i.e. this detection method is especially suited for
 detecting a shift from a relative constant mean. Hence, this is less
 suited for detection in diseases with strong seasonal endemic
 component. Onset of influenza detection is an example where this
 method works particular well.

 In case \code{control$ret == "cases"} then a brute force numerical
 search for the number needed before alarm (NNBA) is performed. That
 is, given the past observations, whats the minimum number which would
 have caused an alarm? Note: Computing this might take a while because
 the search is done by sequentially increasing/decreasing the last
 observation by one for each time point in \code{control$range} and
 then calling the workhorse function of the algorithm again. The argument
 \code{control$maxUpperboundCases} controls the upper limit of this
 search (default is 1e5). 
 Currently, even though the statistic has passed the threshold, the NNBA
 is still computed. After a few time instances what typically happens is
 that no matter the observed value we would have an alarm at this time point. In this case the value of NNBA is set to \code{NA}. Furthermore, the first time
 point is always \code{NA}, unless \code{k<1}.

}
\source{
 The code is an extended R port of the Java code by Marianne
 \enc{Frisén}{Frisen} and Linus \enc{Schiöler}{Schioeler} from the
 CASE project available under the GNU GPL License v3. See
 https://smisvn.smi.se/case/ for further details on the CASE
 project. A manual on how to use an Excel implementation of the method
 is available at \url{http://www.hgu.gu.se/item.aspx?id=16857}.

 The R code contains e.g. the search for NNBA (see details).
}
\author{M. \enc{Höhle}{Hoehle} -- based on Java code by Frisen and \enc{Schiöler}{Schioeler}}
\references{
\enc{Frisén}{Frisen}, Andersson and \enc{Schiöler}{Schioeler} (2009), Robust
outbreak surveillance of epidemics in Sweden, Statistics in
Medicine, 28(3):476-493.

\enc{Frisén}{Frisen} and Andersson (2009) Semiparametric
Surveillance of Monotonic Changes, Sequential Analysis 28(4):434-454.
}
\examples{
#Use data from outbreakP manual (http://www.hgu.gu.se/item.aspx?id=16857)
y <- matrix(c(1,0,3,1,2,3,5,4,7,3,5,8,16,23,33,34,48),ncol=1)

#Generate sts object with these observations
mysts <- new("sts", observed=y, epoch=1:length(y), alarm=y*0,
                    start=c(2000,1), freq=52)

#Run the algorithm and present results
#Only the value of outbreakP statistic
upperbound(outbreakP(mysts, control=list(range=1:length(y),k=100, 
           ret="value")))

#Graphical illustration with number-needed-before-alarm (NNBA) upperbound.
res <- outbreakP(mysts, control=list(range=1:length(y),k=100, 
           ret="cases"))
plot(res,dx.upperbound=0,lwd=c(1,1,3),legend.opts=list(legend=c("Infected","NNBA","Outbreak","Alarm"),horiz=TRUE))

}

\keyword{classif}

<<echo=F>>=

######################################################################
# Workhorse computing the OutbreakP statistic.
# Alarm statistic at end time n is returned.
#
# Author:
# Michael Höhle <hoehle@stat.uni-muenchen.de>
#
# R port of the Java code by Marianne Frisen & Linus Schioler from
# the CASE project. See https://smisvn.smi.se/case/
#
# For a manual on how to use the method see also
# http://www.hgu.gu.se/item.aspx?id=16857
#
# Date:
# 25 May 2010
#
# Parameters:
#  x -- the series with the counts
#
# Returns:
#  value of the alarm statistic at the end of the series x.
######################################################################

calc.outbreakP.statistic <- function(x) {
  #Length of the monitored series
  n <- length(x)
  #Index problem when converting java arrays to R arrays
  x <- c(0,x)
  
  #Initialization (not all parts might be needed)
  leftl <- numeric(n+1);
  y <- numeric(n+1);
  yhat <- numeric(n+1);
  sumwy <- numeric(n+1);
  sumwys <- numeric(n+1);
  sumw <- numeric(n+1);
  w <- numeric(n+1);
  meanl <- numeric(n+1);

  xbar <- 0
  meanl[1] = -Inf
  leftl[1] = 0		

  
  for (i in 1:n) {
    #Initialize
    yhat[i+1] <- x[i+1];
    sumwy[i+1] <- x[i+1];
    sumw[i+1] <- 1;
    meanl[i+1] <- x[i+1];
    leftl[i+1] <- i;
    #Calculate mean
    xbar=xbar+(x[i+1]-xbar)/i
				
    #create plateaus 
    while (meanl[i+1] <= meanl[ (leftl[i+1] - 1) + 1]) {
      #merge sets
      sumwy[i+1] = sumwy[i+1] + sumwy[(leftl[i+1] - 1)+1];
      sumw[i+1] = sumw[i+1] + sumw[(leftl[i+1] - 1)+1];
      meanl[i+1] = sumwy[i+1] / sumw[i+1];
      leftl[i+1] = leftl[(leftl[i+1] - 1)+1];
    }
    
    #calculate yhat 
    for (j in leftl[i+1]:i){
      yhat[j+1] = meanl[i+1];
    }
  }
		
  alarm.stat <- 1
  for (j in 1:n) {
    #Ensure 0/0 = 1 so we don't get NaNs
    div <- ifelse(yhat[j+1]==0 & xbar==0, 1, yhat[j+1]/xbar)
    alarm.stat <- alarm.stat * (div)^x[j+1]
  }
  return(alarm.stat)

##  logalarm <- 0
##  for (j in 1:n) {
##     #Eqn (5) in Frisen et al paper in log form. However: it is undefined
##     #what happens if \hat{\mu}^D(t) == 0 (it is a division by zero). 
##     #We fix 0/0 = 1
##     if (xbar != 0) {
##       if (yhat[j+1] != 0) { #if \hat{\mu}^{C1} == 0 then
##         logalarm = logalarm + x[j+1] * (log(yhat[j+1]) - log(xbar))
##       }
##     } else {
##       if (yhat[j+1] != 0) {
##         stop("Division by zero in Eqn (5) of Frisen paper!")
##       }
##     }
##  }
##  #Done, return the value  
##  return(exp(logalarm))
}

######################################################################
# The detection function in S3 style
######################################################################

algo.outbreakP <- function(disProgObj, control = list(range = range, k=100, ret=c("cases","value"),maxUpperboundCases=1e5)) {
  #Set threshold to some fixed value, i.e. 100
  if(is.null(control[["k",exact=TRUE]]))
    control$k <- 100

  #Set largest observed value to try as upperbound when numerically searching
  #for NNBA in case ret = "cases"
  if(is.null(control[["maxUpperboundCases",exact=TRUE]]))
    control$maxUpperboundCases <- 1e5

  #Which value to return in upperbound?
  control$ret <- match.arg(control$ret, c("value","cases"))
   
  #Initialize the necessary vectors
  alarm <- matrix(data = 0, nrow = length(control$range), ncol = 1)
  upperbound <- matrix(data = 0, nrow = length(control$range), ncol = 1)
  observed <- disProgObj$observed

  #Store results
  count <- 1
  for(i in control$range) {
    statistic <- calc.outbreakP.statistic( observed[seq_len(i)] )
    # store the results in the right order
    alarm[count] <- statistic > control$k

    #Find NNBA or just return value of the test statistic (faster)
    if (control$ret == "cases") {
      #If length is 1 no alarm can be given unless k<1
      if (i<=1) {
        upperbound[count] <- ifelse(control$k>=1, NA, 0)
      } else {
        #Go up or down
        delta <- ifelse(alarm[count], -1, 1)
        #Initialize       
        observedi <- observed[i]
        foundNNBA <- FALSE
        #Loop with modified last observation until alarm is caused (dx=1)
        #or until NO alarm is caused anymore (dx=-1)
        while ( ((delta == -1 & observedi > 0) | (delta == 1 & observedi < 1e5)) & (!foundNNBA)) {
          observedi <- observedi + delta
          newObserved <- c(observed[seq_len(i-1)],observedi)
          statistic <- calc.outbreakP.statistic( newObserved )
          foundNNBA <- (statistic > control$k) == ifelse(alarm[count],FALSE,TRUE)
        }
        upperbound[count] <- ifelse( foundNNBA, observedi + ifelse(alarm[count],1,0), NA) 
      }
    } else {
      upperbound[count] <- statistic
    }

    #Advance time index 
    count <- count + 1
  }

  #Add name and data name to control object.
  control$name <- paste("outbreakP(",control$k,")",sep="")
  control$data <- paste(deparse(substitute(disProgObj)))

  # return alarm and upperbound vectors
  result <- list(alarm = alarm, upperbound = upperbound, disProgObj=disProgObj, control=control)

  class(result) = "survRes" # for surveillance system result
  return(result)
}

