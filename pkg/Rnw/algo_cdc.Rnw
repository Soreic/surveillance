@

\name{algo.cdc}
\alias{algo.cdcLatestTimepoint}
\alias{algo.cdc}
\encoding{latin1}

\title{The CDC Algorithm}
\description{
        Surveillance using the CDC Algorithm
}
\usage{
    algo.cdcLatestTimepoint(disProgObj, timePoint = NULL,
         control = list(b = 5, m = 1, alpha=0.025))
    algo.cdc(disProgObj, control = list(range = range, b= 5, m=1, alpha = 0.025))
}
\arguments{
        \item{disProgObj}{object of class disProg (including the observed and the state chain).}
        \item{timePoint}{time point which shoud be evaluated in \code{algo.cdcLatestTimepoint}. The
                default is to use the latest timepoint.}
        \item{control}{control object: \code{range} determines the desired
                timepoints which should be evaluated, \code{b} describes the number of years to go
                back for the reference values, \code{m} is the half window width for the reference
                values around the appropriate timepoint (see details). The standard definition is \code{b}=5 and \code{m}=1.
        }
}
%
\details{
%
  Using the reference values for calculating an upper limit, alarm is
  given if the actual value is bigger than a computed threshold.
  \code{algo.cdc} calls \code{algo.cdcLatestTimepoint} for the values
  specified in \code{range} and for the system specified in
  \code{control}.  The threshold is calculated by the predictive
  version, i.e.  \deqn{mean(x) + z_{\alpha/2} * sd(x) * \sqrt(1+1/k),}
  which corresponds to Equation 8-1 in the Farrington and Andrews
  chapter.
%
  Note that an aggregation into 4-week blocks occurs in
  \code{algo.cdcLatestTimepoint} and \code{m} denotes number of 4-week
  blocks (months) to use as reference values. This function currently
  does the same for monthly data (not correct!)
 %
}
%
\value{
\item{survRes}{
    \code{algo.cdcLatestTimepoint} returns a list of class \code{survRes} (surveillance result), which
    includes the alarm value (alarm = 1, no alarm = 0) for recognizing an
    outbreak, the threshold value for recognizing the alarm and
    the input object of class disProg.
    
    \code{algo.cdc} gives a list of class \code{survRes} which
    includes the vector of alarm values for every timepoint in
    \code{range}, the vector of threshold values for every timepoint
    in \code{range} for the system specified by \code{b}, \code{w},
    the range and the input object of class disProg.
  }
}
%
\seealso{
        \code{\link{algo.rkiLatestTimepoint}},\code{\link{algo.bayesLatestTimepoint}} and \code{\link{algo.bayes}} for
        the Bayes system.
}
\author{M. Höhle}
\examples{
    # Create a test object
    disProgObj <- sim.pointSource(p = 0.99, r = 0.5, length = 500, 
                      A = 1,alpha = 1, beta = 0, phi = 0,
                      frequency = 1, state = NULL, K = 1.7)

    # Test week 200 to 208 for outbreaks with a selfdefined cdc
    algo.cdc(disProgObj, control = list(range = 400:500,alpha=0.025))
}

%\keyword{}
\source{
Stroup, D., G. Williamson, J. Herndon, and J. Karon (1989). Detection
of aberrations in the occurence of notifiable diseases surveillance data.
Statistics in Medicine 8, 323-329. 

Farrington, C. and N. Andrews (2003). Monitoring the Health of Populations, Chapter Outbreak Detection: Application to Infectious Disease
Surveillance, pp. 203-231. Oxford University Press.
}


<<echo=F>>=


# Implementation of the CDC surveillance system.
# The system evaluates specified timepoints and gives alarm if it recognizes
# an outbreak for this timepoint.
#

algo.cdcLatestTimepoint <- function(disProgObj, timePoint = NULL, control = list(b = 5, m = 1, alpha=0.025)){

  observed <- disProgObj$observed
  freq <- disProgObj$freq

  # If there is no value in timePoint, then take the last value in observed
  if(is.null(timePoint)){
        timePoint = length(observed)
  }

  # check if the vector observed includes all necessary data.
  if((timePoint-(control$b*freq)-control$m*4) < 1){
        stop("The vector of observed is too short!")
  }

  ######################################################################
  #Find which weeks to take -- hoehle 27.3.2007 - fixed bug taking
  #things in the wrong time order (more recent values)
  ######################################################################
  midx <- seq(-control$m*4-3,control$m*4)
  yidx <- ((-control$b):(-1))*freq 
  baseidx  <- sort(rep(yidx,each=length(midx)) + midx)
  months <- rep(1:((2*control$m+1)*control$b),each=4)
  basevec <- as.integer(by(observed[timePoint + baseidx ],months,sum)) 

  # Create a normal distribution based upper confidence interval
  # (we will use the prediction interval described in 
  # Farrington & Andrew (2003))
  upCi <- mean(basevec)+qnorm(1-control$alpha/2)*sd(basevec)*sqrt(1+1/length(basevec))

  #Counts for the current mounth
  yt0 <- sum(observed[timePoint:(timePoint-3)])
  # Alarm if the actual value is larger than the upper limit.
  alarm <- yt0 > upCi
  # Save aggregated score for later visualisation.
  aggr  <- yt0
  result <- list(alarm=alarm, upperbound=upCi,aggr=aggr)
  class(result) = "survRes" # for surveillance system result
  return(result)
}

# 'algo.cdc' calls 'algo.bayesLatestTimepoint' for data points given by range.

algo.cdc <- function(disProgObj, control = list(range = range, b=5, m=1, alpha=0.025)){
  # initialize the necessary vectors
  alarm <- matrix(data = 0, nrow = length(control$range), ncol = 1)
  aggr <- matrix(data = 0, nrow = length(control$range), ncol = 1)
  upperbound <- matrix(data = 0, nrow = length(control$range), ncol = 1)

  #Set control options (standard CDC options)
  if (is.null(control$range)) {
    control$range <- (disProgObj$freq*control$b - control$w):length(disProgObj$observed)
  }
  if (is.null(control$b))        {control$b=5}
  if (is.null(control$w))        {control$m=1}
  if (is.null(control$alpha))    {control$alpha=0.025}

  count <- 1
  for(i in control$range){
    # call algo.cdcLatestTimepoint
    result <- algo.cdcLatestTimepoint(disProgObj, i,control=control)
    # store the results in the right order
    alarm[count] <- result$alarm
    aggr[count] <- result$aggr
    upperbound[count] <- result$upperbound
    count <- count + 1
  }
  #Add name and data name to control object.
  control$name <- paste("cdc(",control$m*4,"*,",0,",",control$b,")",sep="")
  control$data <- paste(deparse(substitute(disProgObj)))

  # Return the vectors-
  # as a special feature CDC objects contain an "aggr" identifier
  # containing the aggregated counts for each week.
  result <- list(alarm = alarm, upperbound = upperbound, disProgObj=disProgObj, control=control, aggr=aggr)

  class(result) = "survRes" # for surveillance system result
  return(result)
}

