@

\name{algo.bayes}
\alias{algo.bayes}
\alias{algo.bayesLatestTimepoint}
\alias{algo.bayes1}
\alias{algo.bayes2}
\alias{algo.bayes3}
\encoding{latin1}

\title{The Bayes System}
\description{
        Evaluation of timepoints with the Bayes subsystem
        1,2 or 3 or a self defined Bayes subsystem.
}
\usage{
  algo.bayesLatestTimepoint(disProgObj, timePoint = NULL,
       control = list(b = 0, w = 6, actY = TRUE,alpha=0.05))
  algo.bayes(disProgObj, control = list(range = range,
       b = 0, w = 6, actY = TRUE,alpha=0.05))
  algo.bayes1(disProgObj, control = list(range = range))
  algo.bayes2(disProgObj, control = list(range = range))
  algo.bayes3(disProgObj, control = list(range = range))
}
\arguments{
        \item{disProgObj}{object of class disProg (including the observed and the state chain)}
        \item{timePoint}{time point which shoud be evaluated in \code{algo.rkiLatestTimepoint}. The
                default is to use the latest timepoint}
        \item{control}{control object: \code{range} determines the desired
                timepoints which should be evaluated, \code{b} describes the number of years to go
                back for the reference values, \code{w} is the half window width for the reference
                values around the appropriate timepoint and \code{actY} is a boolean to decide if
                the year of \code{timePoint} also spend \code{w} reference values of the past. The parameter \code{alpha} is the \eqn{1-\alpha}-quantile to use in order to calculate the upper threshold.
                As default \code{b}, \code{w}, \code{actY} are set for the Bayes 1 system with \code{alpha}=0.05.
        }
}
\value{
\item{survRes}{
    \code{algo.bayesLatestTimepoint} returns a list of class \code{survRes} (surveillance result), which
    includes the alarm value for recognizing an
    outbreak (1 for alarm, 0 for no alarm), the threshold value for recognizing the alarm and
    the input object of class disProg.
    \code{algo.bayes} gives a list of class \code{survRes} which includes the vector
    of alarm values for every timepoint in \code{range} and the vector of threshold values
    for every timepoint in \code{range} for the system specified by \code{b}, \code{w} and
    \code{actY}, the range and the input object of class disProg.
    \code{algo.bayes1} returns the same for the Bayes 1 system, \code{algo.bayes2}
    for the Bayes 2 system and \code{algo.bayes3} for the Bayes 3 system.
  }
}
\details{
  Using the reference values for calculating an upper limit (threshold) via the negative
  binomial distribution, alarm is given if the actual value is bigger or equal than this threshold.
  \code{algo.bayes} calls \code{algo.bayesLatestTimepoint} for the values specified
  in \code{range} and for the system specified in \code{control}.
  \code{algo.bayes1}, \code{algo.bayes2}, \code{algo.bayes3} call
  \code{algo.bayesLatestTimepoint} for the values specified
  in \code{range} for the Bayes 1 system, Bayes 2 system or Bayes 3 system.
  \itemize{
  \item \code{"Bayes 1"} reference values from 6 weeks ago and alpha=0.05 fixed.
  \item \code{"Bayes 2"} reference values from 6 weeks ago and
    13 weeks of the year ago (symmetrical around the
    comparable week). Alpha is fixed at 0.05.
  \item \code{"Bayes 3"}  18 reference values. 9 from the year ago
    and 9 from two years ago (also symmetrical around the
    comparable week). Alpha is fixed at 0.05.
  }
}
\seealso{
        \code{\link{algo.call}}, \code{\link{algo.rkiLatestTimepoint}} and \code{\link{algo.rki}} for
        the RKI system.
}
\author{M. Höhle, A. Riebler, C. Lang}
\examples{
    disProg <- sim.pointSource(p = 0.99, r = 0.5, length = 208, A = 1,
                                    alpha = 1, beta = 0, phi = 0,
                                    frequency = 1, state = NULL, K = 1.7)

    # Test for bayes 1 the latest timepoint
    algo.bayesLatestTimepoint(disProg)

    # Test week 200 to 208 for outbreaks with a selfdefined bayes
    algo.bayes(disProg, control = list(range = 200:208, b = 1,
                                                w = 5, actY = TRUE,alpha=0.05))
    # The same for bayes 1 to bayes 3
    algo.bayes1(disProg, control = list(range = 200:208,alpha=0.05))
    algo.bayes2(disProg, control = list(range = 200:208,alpha=0.05))
    algo.bayes3(disProg, control = list(range = 200:208,alpha=0.05))
}

\keyword{classif}
\source{
Riebler, A. (2004), Empirischer Vergleich von statistischen Methoden zur
Ausbruchserkennung bei Surveillance Daten, Bachelor's thesis.
}
<<echo=F>>=


# Implementation of the Bayes system.
# The system evaluates specified timepoints and gives alarm if it recognizes
# an outbreak for this timepoint.
#
# Features:
# Choice between different Bayes sub-systems (difference in reference values).

algo.bayesLatestTimepoint <- function(disProgObj, timePoint = NULL, control = list(b = 0, w = 6, actY = TRUE, alpha=0.05)){

  observed <- disProgObj$observed
  freq <- disProgObj$freq

  # If there is no value in timePoint, then take the last value in observed
  if(is.null(timePoint)){
        timePoint = length(observed)
  }

  #If no level specified.
  
  # check if the vector observed includes all necessary data.
  if((timePoint-(control$b*freq)-control$w) < 1){
        stop("The vector of observed is too short!")
  }

  # construct the reference values
  basevec <- c()
  # if actY == TRUE use also the values of the year of timepoint
  if(control$actY){
        basevec <- observed[(timePoint - control$w):(timePoint - 1)]
  }
  # check if you need more referencevalues of the past
  if(control$b >= 1){
    for(i in 1:control$b){
        basevec <- c(basevec, observed[(timePoint-(i*freq)-control$w):(timePoint-(i*freq)+control$w)])
    }
  }

  # get the parameter for the negative binomial distribution
  sumBasevec <- sum(basevec)
  lengthBasevec <- length(basevec)

  # compute the upper limit of the 95% CI.
  upCi <- qnbinom(1-control$alpha, sumBasevec + 1/2, (lengthBasevec)/(lengthBasevec + 1))

  # give alarm if the actual value is larger than the upper limit.
  alarm <- observed[timePoint] >= upCi

  result <- list(alarm=alarm, upperbound=upCi, disProgObj=disProgObj)
  class(result) = "survRes" # for surveillance system result

  return(result)
}

# 'algo.bayes' calls 'algo.bayesLatestTimepoint' for data points given by range.

algo.bayes <- function(disProgObj, control = list(range = range, b = 0, w = 6, actY = TRUE,alpha=0.05)){

  # Set the default values if not yet set
  if(is.null(control$b)){
    # value from bayes 1
    control$b <- 0
  }
  if(is.null(control$w)){
    # value from bayes 1
    control$w <- 6
  }
  if(is.null(control$alpha)){
    # value from bayes 1
    control$alpha <- 0.05
  }
  if(is.null(control$actY)){
    # value from bayes 1
    control$actY <- TRUE
  }

  # initialize the necessary vectors
  alarm <- matrix(data = 0, nrow = length(control$range), ncol = 1)
  upperbound <- matrix(data = 0, nrow = length(control$range), ncol = 1)

  count <- 1
  for(i in control$range){
    # call algo.bayesLatestTimepoint
    result <- algo.bayesLatestTimepoint(disProgObj, i, control = control)
    # store the results in the right order
    alarm[count] <- result$alarm
    upperbound[count] <- result$upperbound
    count <- count + 1
  }
  #Add name and data name to control object.
  control$name <- paste("bayes(",control$w,",",control$w*control$actY,",",control$b,")",sep="")
  control$data <- paste(deparse(substitute(disProgObj)))

  # return alarm and upperbound vectors
  result <- list(alarm = alarm, upperbound = upperbound, disProgObj=disProgObj,control=control)

  class(result) = "survRes" # for surveillance system result
  return(result)
}

algo.bayes1 <- function(disProgObj, control = list(range = range)){
  algo.bayes(disProgObj, control = list(range = control$range, b = 0, w = 6, actY = TRUE,alpha=0.05))
}
algo.bayes2 <- function(disProgObj, control = list(range = range)){
  algo.bayes(disProgObj, control = list(range = control$range, b = 1, w = 6, actY = TRUE,alpha=0.05))
}
algo.bayes3 <- function(disProgObj, control = list(range = range)){
  algo.bayes(disProgObj, control = list(range = control$range, b = 2, w = 4, actY = FALSE,alpha=0.05))
}
