\documentclass[article]{jss}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% almost as usual
\author{Michael H\"ohle\\Ludwig-Maximilians-Universit\"at\\M\"unchen \And
        Sebastian Meyer\\Ludwig-Maximilians-Universit\"at\\M\"unchen}
\title{Stochastic Epidemic Models: Analysis of Infectious Diseases using \pkg{surveillance} in \proglang{R}}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Michael H\"ohle, Sebastian Meyer} %% comma-separated
\Plaintitle{Stochastic Epidemic Models: Analysis of Infectious Diseases using surveillance in R} %% without formatting
% \Shorttitle{A Capitalized Title} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{
  The abstract of the article. \citep{Hoehle2007}
}
\Keywords{infectious disease epidemiology, stochastic compartmental models, \proglang{R}}
\Plainkeywords{infectious disease epidemiology, stochastic compartmental models, R} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2009}
%% \Submitdate{2009-09-29}
%% \Acceptdate{2009-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Michael H\"ohle\\
  Institut f\"ur Statistik\\
  Ludwig-Maximilians-Universit\"at M\"unchen\\
  Ludwigstrasse 33\\
  D-80539 M\"unchen\\
  E-mail: \email{Michael.Hoehle@stat.uni-muenchen.de}\\
  URL: \url{http://www.statistik.lmu.de/~hoehle/}
}
%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/1/31336-5053
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}
\DefineVerbatimEnvironment{Sinput}{Verbatim}{fontshape=sl, fontsize=\footnotesize}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{fontsize=\footnotesize}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% add-ons by the authors %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{bm}
\newcommand{\R}{\proglang{R}}

%% end of add-ons %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

%%% Sweave options
\SweaveOpts{strip.white=true, prefix=true, prefix.string=figs/Sweave, use.cache=true, height=4, width=8}
\setkeys{Gin}{width=0.8\textwidth}

<<Setup, echo=false, results=hide>>=
# change prompt, width of Schunks and str()-outputs
options(prompt = "R> ", width = 80, str = strOptions(strict.width = "wrap"))

# load packages
library("surveillance")
library("xtable")
library("maptools")
@


\section{Introduction}


\section{Additive-multiplicative intensity model}


\section[Using package surveillance]{Using package \pkg{surveillance}}

As of version \code{1.3-0} the contributed \R\ package \pkg{surveillance} contains an
implementation of the above methodology. This section describes the use of the
corresponding \proglang{S3} functions with example data from the German Federal
State Baden-W\"urttemberg (BW).

%%%%%%%%% evaluate chunks which load and prepare data, but echo them later
<<prepare data, echo=false>>=
# load data in wide format
load("data/bw.RData")

# transform data into long format
years <- 2002:2006
bwLong <- reshape(bw,
                  direction = "long", timevar = "year", times = years,
                  idvar = "countyID",
                  varying = list(paste("inf",years,sep=""),
                                 paste("temp",years,sep=""),
                                 paste("rain",years,sep=""),
                                 paste("sun",years,sep="")),
                  v.names = c("casesOfRelatedDisease", "temperature",
                              "precipitation", "sunshine"))

# year 2001 as basis
bwLong$start <- bwLong$year - 2001

# create stop column
bwLong$stop <- bwLong$start + 1

# avoid large scales (numerically disadvantageous due to exp(Z%*%beta) in conditional intensity function)
# transform rainfall from [mm] to [cm]
bwLong$precipitation <- bwLong$precipitation / 10
# transform sunshine from [h] to [days]
# bwLong$sunshine <- bwLong$sunshine / 24
# transform popdensity from [habitants / km^2] to [100 habitants / km^2]
bwLong$popdensity <- bwLong$popdensity / 100
@

<<simulateSIRS_parameters, echo=false>>=
epiformula <- cbind(start, stop) ~ cox(temperature) + cox(precipitation)
beta <- c(0.2, 0.02)
h0 <- -4
alpha <- c(0.4, 0.2, 0.1, 0)
@
<<simulateSIRS_distancekernel, echo=false>>=
knots <- c(0.5, 1.5, 2)
f <- list(B1 = function(D) D < knots[1],
          B2 = function(D) D >= knots[1] & D < knots[2],
          B3 = function(D) D >= knots[2] & D < knots[3],
          B4 = function(D) D >= knots[3] & is.finite(D))
@

<<simulateSIRS_check, echo=false, results=hide>>=
# check if values of exp(Z %*% beta) are numerically feasible
summary( wZ <- t(t(as.matrix(cbind(1, bwLong[c("temperature", "precipitation")]))) * c(h0,beta)) )
summary( exp( rowSums(wZ) ) )
@

<<simulateSIRS, echo=false, results=hide>>=
set.seed(1)
epi_SIRS <- simEpidata(epiformula, data = bwLong, id.col = "county", I0.col = NULL,
    coords.cols = c("longitude", "latitude"), beta = beta, h0 = h0, f = f, alpha = alpha,
    infPeriod = function(ids) rexp(length(ids), 4),
    remPeriod = function(ids) rep(1, length(ids)),
    end = 6, trace = FALSE)
@


\subsection{Input data structure for epidemics}

The input data structure for epidemics inherits from counting processes as
implemented by the class \code{Surv} of the package \pkg{survival}.
Specifically, the observation period is splitted up into \emph{consecutive} time
intervals of constant infection intensities. As $\lambda_i(t)$ only changes at
the time points, where the set of infected individuals $I(t)$ or some endemic
covariate change, those occurrences define the break points of the time
intervals. To make things clearer we simulated an SIRS epidemic, which spreads
over the counties of BW:

<<echo=false>>=
inputdata <- epi_SIRS
class(inputdata) <- "data.frame"
inputdata <- inputdata[-c(1,tail(seq_len(ncol(inputdata)),length(f)))]
names(inputdata)[1] <- "county"

idlevels <- levels(inputdata[["id"]])
N <- length(idlevels)
origwidth <- options(width = 120)
@

<<show inputdata>>=
head(inputdata)
@

<<echo=false>>=
options(origwidth)
@

The data frame consists of several blocks of \Sexpr{N} rows for each of those
time intervals. All rows in a block share the same start and stop values and
there is one row per individual (county) in the block. Each row describes the
(fixed) state of the individual during the interval given by the \code{start}
and \code{stop} columns. This includes the coordinates of the individual, here
the \code{longitude} and the \code{latitude} of the county's centroid. Note that
these are not supposed to change during the whole course of the epidemic. In
contrast, there are also the time dependent covariates \code{temperature} and
\code{precipitation}. The susceptibility status and the I and R events of the
epidemic are captured by the columns \code{atRiskY}, \code{event} and
\code{Revent}, respectively. The \code{atRiskY} column indicates if the
individual was at risk of becoming infected during the time interval
(\code{start}; \code{stop}]. The event columns indicate, which individual was
infected or removed at the \code{stop} time. Note that there may not be more
than one event (infection or removal) in a single block. Thus, in a single
block, only one entry in the \code{event} and \code{Revent} columns may be 1,
all others are 0. This rule follows the assumption that there are no concurrent
events.


\subsection[Generating an object of class "epidata"]{Generating an object of class \code{"epidata"}}

In order to make use of the functionality of the package, the data has to be converted to an object of class \code{"epidata"}. The function \code{as.epidata} does the following:
\begin{itemize}
    \item identify the columns in the input data
	\item check the input data for consistency
	\item add the variable \code{BLOCK} as an index for the time intervals
	\item reorder the columns
	\item sort the data by the \code{BLOCK} and id column
	\item generate the \emph{epidemic} covariates $\bm{x}_i(t)$
	\item attach useful attributes to the resulting data frame
\end{itemize}

Besides the creation of a standardized data format for epidemics, the main
purpose of the function is the last point -- the calculation of the epidemic
covariates one would like to incorporate in the intensity model. As an example,
we will fit a decreasing step function as the distance kernel, specifically
$f(u) = \sum_{m=1}^\Sexpr{length(f)} \alpha_m \, B_m(u)$ with
% \begin{center}
<<echo=false, results=tex>>=
.allknots <- c(0, knots, "\\infty")
#.tab <- rbind(m = seq_along(f),
#              "$\\alpha$" = alpha,
#              "$B_m$" = paste("$I_{[", .allknots[-length(.allknots)], ";", .allknots[-1], ")}(u)$", sep="")
#)
#print(xtable(.tab, align="r|cccc"), hline.after=1, include.colnames=FALSE, floating = FALSE, sanitize.text.function=function(x){x})
cat(paste("$B_{", seq_along(f), "} = ", "I_{[", .allknots[-length(.allknots)],
          ";", .allknots[-1], ")}(u)$", sep="", collapse = ", "), "\n")
@
% \end{center}

We convert the \code{inputdata} to an object of class \code{"epidata"} by
<<data2epidata>>=
<<simulateSIRS_distancekernel>>
bwepi <- as.epidata(inputdata,
    id.col = "county", start.col = "start", stop.col = "stop",
    atRiskY.col = "atRiskY", event.col = "event", Revent.col = "Revent",
    coords.cols = c("longitude", "latitude"), f = f)
@
and obtain the following data frame:
<<echo=false>>=
origwidth <- options(width = 100)
@
<<showepidata, echo=TRUE, eval=FALSE>>=
head(bwepi)
@ 
<<echo=FALSE>>=
suppressWarnings(head(bwepi))
@ 
<<>>=
str(bwepi)
@ 
<<echo=false>>=
options(origwidth)
@

The package offers several methods and functions for the \code{"epidata"} class: \code{summary.epidata}, \code{plot.epidata}, \code{animate} and \code{twinSIR}.


<<bw, fig = true, echo = false, height=7, width=7>>=
proj4string <- CRS("+proj=longlat +datum=WGS84 +ellps=WGS84")
bwShape <- readShapeSpatial("data/bw.shape/bw.shp", proj4string = proj4string)
plot(bwShape, axes=TRUE, las=1, border = "blue", col="lightgrey")
points(coordinates(bwShape), cex = 0.6, pch = 20)
text(coordinates(bwShape), labels = bwShape[["ID"]], cex = 0.5, pos = 1, offset = 0.2)
@



\section*{Acknowledgments}

We thank Karen Brune from the Department for Environment \& Health of the
University of Bielefeld, School of Public Health - WHO Collaborating Centre, for
the preparation of the Baden-W\"urttemberg weather data, collected by the German
meteorological service (Deutscher Wetterdienst, DWD). The shapefile of the
counties of Baden-W\"urttemberg was made available by the geographic data centre
(Geodatenzentrum, GDZ) of the German Federal Agency for Cartography and Geodesy
(Bundesamt f\"ur Kartographie und Geod\"asie, BKG).

% \bibliographystyle{jss}
\bibliography{bibliography}


\end{document}
