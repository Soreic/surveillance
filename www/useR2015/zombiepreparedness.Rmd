---
title: "Zombie Preparedness"
author: "[Michael HÃ¶hle, Department of Mathematics, Stockholm University](http://www.math.su.se/~hoehle)"
date: "1 Jul 2015"
output: html_document
---

This is an knitr/R Markdown document containing the [surveillance package](http://surveillance.r-forge.r-project.org/) 'backend' of the useR2015 talk about 'Zombie Preparedness'. Disclaimer: No claim is made that this is nice code - focus is on the reprodcubility of the results! Furthermore, to get improved visualization some of the standard plot routines of `sts`were tweaked. Hence, some of the code may look more cumbersome than it would be in order to just get a default plot. 

```{r message=FALSE}
######################################################################
# Load surveillance package and load the simulated zombie outbreak
# data, which are generated by simzombie.R
######################################################################
library("surveillance")
load("sim.RData")
#Load add-on functions and some arguments for running the algos.
source("helper-funcs.R")

#knitr setup
require("knitr")
opts_chunk$set(warning=FALSE)
```

Add delay distribution which is assumed to be time-stationary.
```{r}
pmfDelay <- c(0.15,0.2,0.3,0.15,0.2)
```
The range of the delay is [`r range(seq_len(length(pmfDelay))-1)`] weeks and the 
median is `r which.max(cumsum(pmfDelay) >= 0.5)-1` weeks.

The fictive data (available as object `stsw`) to be monitored up to the current data of `r dNow` are: 

```{r fig.keep='high'}
###Visualization
xlim <- c(max(which(epoch(stsw) <= as.Date("2015-01-10"))),
          max(which(epoch(stsw) <= as.Date("2015-08-05"))))
ylim <- c(0,23) #c(0,23)

args <- modifyList(args,list(ylim=ylim))

thePast <- (epoch(stsw) <= dNow)
sts2 <- stsw
sts2@observed[!thePast,] <- 0
do.call("plot",modifyList(args,list(x=sts2,ylim=NULL)))
addNow2Plot(dNow) 

```

Set the options for the monitoring algorithms. Since we select a pretty 
high quantile of the predictive distribution many simulations from the
distribution are needed.

```{r fig.keep='all'}
#Options for the surveillance using bodaDelay -- initially we run without
#delay adjustments.
alpha <- 0.001
survControl <-  list(b = 4, w = 4,
                      pastAberrations = FALSE, mc.munu=10000, mc.y=1000,
                      verbose = FALSE,
                      alpha = alpha, trend = FALSE,
                      limit54=c(0,50),
                      noPeriods = 10, pastWeeksNotIncluded = 13, #26
                      delay=FALSE,inferenceMethod="asym")

#Show result using unadjusted monitoring (all package magic done in the plotOne
#function here, so not so illustrative for the package syntax! Look for the line
#
#s.far <- bodaDelay(sts,modifyList(survControl,list(range=rangeTest)))
#
#in plotOne to see the algorithmic action.
plotOne(stsw, dNow=dNow, dUp2=dNow, xlim=xlim,ylim=ylim,survControl=survControl)
addNow2Plot(dNow,withDate=FALSE)
```

Monitoring in the 2nd week doesn't produce any alarms, but monitoring in the 3rd week
yields an alarm.
```{r fig.keep='high', cache=TRUE}
dAlarm <- plotOne(stsw, dNow=dNow, dUp2=dNow+2*7,
                  xlim=xlim,ylim=ylim,survControl=survControl)
```

Split true counts according to the delay distribution and convert reporting triangle into a `data.frame`.

```{r cache=TRUE}
set.seed(123)
rT <- t(sapply(seq_len(nrow(stsw)), function(i) {
  rmultinom(n=1, size=as.numeric(observed(stsw))[i],prob=pmfDelay)
}))

##This can probably be done more efficient and nicer in code!
rt.df <- NULL
for (t in 1:nrow(rT)) {
  for (d in 0:(ncol(rT)-1)) {
    rt.df <- rbind(rt.df, data.frame(dEvent=rep(epoch(stsw)[t],rT[t,d+1]),dReport=rep(epoch(stsw)[t]+7*d,rT[t,d+1])))
  }
}
```

Nowcast the observation using the Bayesian model taking the right-truncation of the
delay distribution into account when estimating it. Note: Change-point models
are also possible for the delay.

```{r chache=TRUE}
#Small helper function to convert nowcast rT to Maelle rT. This needs
#to be improved in the future. Potentially by using the stsNC class....
rT2rT <- function(rT) {
  rTnew <- attributes(rT)
  rTnew$n <- as.matrix(rT)
  return(rTnew)
}

###Build reporting triangle and use Bayesian nowcasting taking the
###right-truncation into account (see ?nowcast).
nc.control <- list(N.tInf.prior=structure("poisgamma",
                       mean.lambda=mean(rowSums(rT)),
                       var.lambda=var(rowSums(rT))),
                   nSamples=1e2)

nc <- nowcast(now=dAlarm-2,when=rev(seq(dAlarm-2,length.out=5,by="-1 week")),
              data=rt.df,dEventCol="dEvent",dReportCol="dReport",
              D=length(pmfDelay)-1,
              aggregate.by="1 week", ##Note: this uses mondays!
              method="bayes.trunc",control=nc.control)

```

```{r fig.keep='high',cache=TRUE}
plotOne(stsByDate(dAlarm), dNow=dNow, dUp2=dAlarm, xlim=xlim,ylim=ylim, stsTruth=stsw,survControl=survControl)
surveillance.options("colors"=c(nowSymbol="darkgreen",piBars="darkgreen"))
par(xpd=TRUE)
#Overlay the nowcasts
plot(nc,add=TRUE,legend.opts=NULL,axes=FALSE,lty=c(1,1,1,1),col=c(NA,NA,"darkgreen"),lwd=c(1,1,3))
```

Function to do and visualize delay adjusted monitoring for a sequence of increasing time points (4 weeks in total) - note the green 'now' symbol advancing. Note that we in none of the cases would have gotten an alarm with the unadjusted monitoring, wheras
the adjusted monitoring gives a signal after 3 weeks.

```{r results='hide', cache=TRUE}
#Params: 
#  i - number of weeks beyong dAlarm
plotDelayAdj <- function(i=0) {
  dAlarm <- dAlarm+i*7
  
  #Extract monitoring triangle
  nc <- nowcast(now=dAlarm-2,when=rev(seq(dAlarm-2,length.out=5,by="-1 week")),
                data=rt.df,dEventCol="dEvent",dReportCol="dReport",
                D=length(pmfDelay)-1,
                aggregate.by="1 week", ##this uses mondays!
                method="unif",control=nc.control)

  #Performing monitoring based on the reporting triangle.
  stswReduced <- nc[1:nrow(reportingTriangle(nc)),]
  stswReduced@control$reportingTriangle <- rT2rT(nc@reportingTriangle)
  s.bd <- bodaDelay(stswReduced, modifyList(survControl,list(delay=TRUE,range=which( (epoch(stsw) >= dNow) & (epoch(stsw) <= dAlarm))
)))

  #Show results
  plotOne(stsByDate(dAlarm), dNow=dNow, dUp2=dAlarm, xlim=xlim,ylim=ylim, survControl=survControl, stsTruth=stsw, alarmVec=alarms(s.bd))
  first <- which(epoch(stsw) == dNow) #+ 1
  up2   <- which(epoch(stsw) == dAlarm)
  upper <- as.numeric(upperbound(s.bd))
  lines(c(first:up2,up2+1)-0.5,c(upper,tail(upper,n=1)),type="s",lwd=3,col="orange")
  legend(x="topleft",c("no delay adjustment","with delay adjustment"),col=c("darkred","orange"),lwd=3,lty=1)
  addNow2Plot(dAlarm,withDate=FALSE)
  invisible()
}

par(mfrow=c(2,2))  
plotDelayAdj(i=0)
plotDelayAdj(i=1)
plotDelayAdj(i=2)
plotDelayAdj(i=3)

```

How did the time series develop?

```{r}
do.call("plot",modifyList(args,list(x=stsw,ylim=NULL)))
addNow2Plot(dNow,withDate=TRUE)
```

